/* tslint:disable */
/* eslint-disable */
/**
 * resume_api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface ContactMethodCreate
 */
export interface ContactMethodCreate {
  /**
   *
   * @type {string}
   * @memberof ContactMethodCreate
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ContactMethodCreate
   */
  url: string;
}
/**
 *
 * @export
 * @interface ContactMethodRead
 */
export interface ContactMethodRead {
  /**
   *
   * @type {string}
   * @memberof ContactMethodRead
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ContactMethodRead
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof ContactMethodRead
   */
  id: string;
}
/**
 *
 * @export
 * @interface ContactMethodUpdate
 */
export interface ContactMethodUpdate {
  /**
   *
   * @type {string}
   * @memberof ContactMethodUpdate
   */
  title?: string | null;
  /**
   *
   * @type {string}
   * @memberof ContactMethodUpdate
   */
  url?: string | null;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface JobCreate
 */
export interface JobCreate {
  /**
   *
   * @type {string}
   * @memberof JobCreate
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof JobCreate
   */
  start_date: string;
  /**
   *
   * @type {string}
   * @memberof JobCreate
   */
  end_date?: string;
  /**
   *
   * @type {string}
   * @memberof JobCreate
   */
  details: string;
  /**
   *
   * @type {Array<string>}
   * @memberof JobCreate
   */
  responsibilities?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JobCreate
   */
  tech_stack?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JobCreate
   */
  tools?: Array<string>;
}
/**
 *
 * @export
 * @interface JobRead
 */
export interface JobRead {
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  start_date: string;
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  end_date?: string;
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  details: string;
  /**
   *
   * @type {Array<string>}
   * @memberof JobRead
   */
  responsibilities?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JobRead
   */
  tech_stack?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JobRead
   */
  tools?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof JobRead
   */
  picture_url?: string | null;
}
/**
 *
 * @export
 * @interface JobUpdate
 */
export interface JobUpdate {
  /**
   *
   * @type {string}
   * @memberof JobUpdate
   */
  title?: string | null;
  /**
   *
   * @type {string}
   * @memberof JobUpdate
   */
  start_date?: string | null;
  /**
   *
   * @type {string}
   * @memberof JobUpdate
   */
  end_date?: string | null;
  /**
   *
   * @type {string}
   * @memberof JobUpdate
   */
  details?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof JobUpdate
   */
  responsibilities?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof JobUpdate
   */
  tech_stack?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof JobUpdate
   */
  tools?: Array<string> | null;
}
/**
 *
 * @export
 * @interface Lang
 */
export interface Lang {
  /**
   *
   * @type {string}
   * @memberof Lang
   */
  color?: string | null;
  /**
   *
   * @type {string}
   * @memberof Lang
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Lang
   */
  percentage?: number | null;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   *
   * @type {string}
   * @memberof Message
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface ProfileRead
 */
export interface ProfileRead {
  /**
   *
   * @type {string}
   * @memberof ProfileRead
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProfileRead
   */
  about?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProfileRead
   */
  id: string;
}
/**
 *
 * @export
 * @interface ProfileUpdate
 */
export interface ProfileUpdate {
  /**
   *
   * @type {string}
   * @memberof ProfileUpdate
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProfileUpdate
   */
  about?: string | null;
}
/**
 *
 * @export
 * @interface ProjectRead
 */
export interface ProjectRead {
  /**
   *
   * @type {string}
   * @memberof ProjectRead
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof ProjectRead
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectRead
   */
  description: string;
  /**
   *
   * @type {Array<Lang>}
   * @memberof ProjectRead
   */
  langs?: Array<Lang>;
  /**
   *
   * @type {boolean}
   * @memberof ProjectRead
   */
  public?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProjectRead
   */
  id: string;
}
/**
 *
 * @export
 * @interface ProjectUpdate
 */
export interface ProjectUpdate {
  /**
   *
   * @type {boolean}
   * @memberof ProjectUpdate
   */
  public?: boolean | null;
}
/**
 *
 * @export
 * @interface ResumeRead
 */
export interface ResumeRead {
  /**
   *
   * @type {boolean}
   * @memberof ResumeRead
   */
  public?: boolean;
  /**
   *
   * @type {string}
   * @memberof ResumeRead
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ResumeRead
   */
  nickname: string;
}
/**
 *
 * @export
 * @interface ResumeUpdate
 */
export interface ResumeUpdate {
  /**
   *
   * @type {boolean}
   * @memberof ResumeUpdate
   */
  public?: boolean | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<ValidationErrorLocInner>}
   * @memberof ValidationError
   */
  loc: Array<ValidationErrorLocInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}

/**
 * ContactMethodsApi - axios parameter creator
 * @export
 */
export const ContactMethodsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Contact Method Current User
     * @param {ContactMethodCreate} contactMethodCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContactMethodCurrentUserContactMethodsMePost: async (
      contactMethodCreate: ContactMethodCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'contactMethodCreate' is not null or undefined
      assertParamExists(
        "createContactMethodCurrentUserContactMethodsMePost",
        "contactMethodCreate",
        contactMethodCreate,
      );
      const localVarPath = `/contact-methods/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactMethodCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Contact Method Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContactMethodCurrentUserContactMethodsMeIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        "deleteContactMethodCurrentUserContactMethodsMeIdDelete",
        "id",
        id,
      );
      const localVarPath = `/contact-methods/@me/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read Contact Methods Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readContactMethodsCurrentUserContactMethodsMeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/contact-methods/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Contact Method Current User
     * @param {string} id
     * @param {ContactMethodUpdate} contactMethodUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContactMethodCurrentUserContactMethodsMeIdPatch: async (
      id: string,
      contactMethodUpdate: ContactMethodUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        "updateContactMethodCurrentUserContactMethodsMeIdPatch",
        "id",
        id,
      );
      // verify required parameter 'contactMethodUpdate' is not null or undefined
      assertParamExists(
        "updateContactMethodCurrentUserContactMethodsMeIdPatch",
        "contactMethodUpdate",
        contactMethodUpdate,
      );
      const localVarPath = `/contact-methods/@me/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactMethodUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContactMethodsApi - functional programming interface
 * @export
 */
export const ContactMethodsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ContactMethodsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Contact Method Current User
     * @param {ContactMethodCreate} contactMethodCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContactMethodCurrentUserContactMethodsMePost(
      contactMethodCreate: ContactMethodCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContactMethodRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createContactMethodCurrentUserContactMethodsMePost(
          contactMethodCreate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ContactMethodsApi.createContactMethodCurrentUserContactMethodsMePost"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Contact Method Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContactMethodCurrentUserContactMethodsMeIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteContactMethodCurrentUserContactMethodsMeIdDelete(
          id,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ContactMethodsApi.deleteContactMethodCurrentUserContactMethodsMeIdDelete"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read Contact Methods Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readContactMethodsCurrentUserContactMethodsMeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ContactMethodRead>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readContactMethodsCurrentUserContactMethodsMeGet(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ContactMethodsApi.readContactMethodsCurrentUserContactMethodsMeGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Contact Method Current User
     * @param {string} id
     * @param {ContactMethodUpdate} contactMethodUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateContactMethodCurrentUserContactMethodsMeIdPatch(
      id: string,
      contactMethodUpdate: ContactMethodUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContactMethodRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateContactMethodCurrentUserContactMethodsMeIdPatch(
          id,
          contactMethodUpdate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ContactMethodsApi.updateContactMethodCurrentUserContactMethodsMeIdPatch"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ContactMethodsApi - factory interface
 * @export
 */
export const ContactMethodsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContactMethodsApiFp(configuration);
  return {
    /**
     *
     * @summary Create Contact Method Current User
     * @param {ContactMethodCreate} contactMethodCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContactMethodCurrentUserContactMethodsMePost(
      contactMethodCreate: ContactMethodCreate,
      options?: any,
    ): AxiosPromise<ContactMethodRead> {
      return localVarFp
        .createContactMethodCurrentUserContactMethodsMePost(
          contactMethodCreate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Contact Method Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContactMethodCurrentUserContactMethodsMeIdDelete(
      id: string,
      options?: any,
    ): AxiosPromise<Message> {
      return localVarFp
        .deleteContactMethodCurrentUserContactMethodsMeIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read Contact Methods Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readContactMethodsCurrentUserContactMethodsMeGet(
      options?: any,
    ): AxiosPromise<Array<ContactMethodRead>> {
      return localVarFp
        .readContactMethodsCurrentUserContactMethodsMeGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Contact Method Current User
     * @param {string} id
     * @param {ContactMethodUpdate} contactMethodUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContactMethodCurrentUserContactMethodsMeIdPatch(
      id: string,
      contactMethodUpdate: ContactMethodUpdate,
      options?: any,
    ): AxiosPromise<ContactMethodRead> {
      return localVarFp
        .updateContactMethodCurrentUserContactMethodsMeIdPatch(
          id,
          contactMethodUpdate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContactMethodsApi - object-oriented interface
 * @export
 * @class ContactMethodsApi
 * @extends {BaseAPI}
 */
export class ContactMethodsApi extends BaseAPI {
  /**
   *
   * @summary Create Contact Method Current User
   * @param {ContactMethodCreate} contactMethodCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactMethodsApi
   */
  public createContactMethodCurrentUserContactMethodsMePost(
    contactMethodCreate: ContactMethodCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ContactMethodsApiFp(this.configuration)
      .createContactMethodCurrentUserContactMethodsMePost(
        contactMethodCreate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Contact Method Current User
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactMethodsApi
   */
  public deleteContactMethodCurrentUserContactMethodsMeIdDelete(
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ContactMethodsApiFp(this.configuration)
      .deleteContactMethodCurrentUserContactMethodsMeIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read Contact Methods Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactMethodsApi
   */
  public readContactMethodsCurrentUserContactMethodsMeGet(
    options?: RawAxiosRequestConfig,
  ) {
    return ContactMethodsApiFp(this.configuration)
      .readContactMethodsCurrentUserContactMethodsMeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Contact Method Current User
   * @param {string} id
   * @param {ContactMethodUpdate} contactMethodUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactMethodsApi
   */
  public updateContactMethodCurrentUserContactMethodsMeIdPatch(
    id: string,
    contactMethodUpdate: ContactMethodUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ContactMethodsApiFp(this.configuration)
      .updateContactMethodCurrentUserContactMethodsMeIdPatch(
        id,
        contactMethodUpdate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Job Current User
     * @param {JobCreate} jobCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobCurrentUserJobsMePost: async (
      jobCreate: JobCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobCreate' is not null or undefined
      assertParamExists(
        "createJobCurrentUserJobsMePost",
        "jobCreate",
        jobCreate,
      );
      const localVarPath = `/jobs/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Job Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobCurrentUserJobsMeIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteJobCurrentUserJobsMeIdDelete", "id", id);
      const localVarPath = `/jobs/@me/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read Jobs Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readJobsCurrentUserJobsMeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/jobs/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Job Current User
     * @param {string} id
     * @param {JobUpdate} jobUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJobCurrentUserJobsMeIdPatch: async (
      id: string,
      jobUpdate: JobUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateJobCurrentUserJobsMeIdPatch", "id", id);
      // verify required parameter 'jobUpdate' is not null or undefined
      assertParamExists(
        "updateJobCurrentUserJobsMeIdPatch",
        "jobUpdate",
        jobUpdate,
      );
      const localVarPath = `/jobs/@me/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Job Picture Current User
     * @param {string} id
     * @param {File} newPicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJobPictureCurrentUserJobsMeIdPicturePut: async (
      id: string,
      newPicture: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        "updateJobPictureCurrentUserJobsMeIdPicturePut",
        "id",
        id,
      );
      // verify required parameter 'newPicture' is not null or undefined
      assertParamExists(
        "updateJobPictureCurrentUserJobsMeIdPicturePut",
        "newPicture",
        newPicture,
      );
      const localVarPath = `/jobs/@me/{id}/picture`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (newPicture !== undefined) {
        localVarFormParams.append("new_picture", newPicture as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Job Current User
     * @param {JobCreate} jobCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createJobCurrentUserJobsMePost(
      jobCreate: JobCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createJobCurrentUserJobsMePost(
          jobCreate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JobsApi.createJobCurrentUserJobsMePost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Job Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJobCurrentUserJobsMeIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteJobCurrentUserJobsMeIdDelete(
          id,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JobsApi.deleteJobCurrentUserJobsMeIdDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read Jobs Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readJobsCurrentUserJobsMeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JobRead>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readJobsCurrentUserJobsMeGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JobsApi.readJobsCurrentUserJobsMeGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Job Current User
     * @param {string} id
     * @param {JobUpdate} jobUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateJobCurrentUserJobsMeIdPatch(
      id: string,
      jobUpdate: JobUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateJobCurrentUserJobsMeIdPatch(
          id,
          jobUpdate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JobsApi.updateJobCurrentUserJobsMeIdPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Job Picture Current User
     * @param {string} id
     * @param {File} newPicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateJobPictureCurrentUserJobsMeIdPicturePut(
      id: string,
      newPicture: File,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateJobPictureCurrentUserJobsMeIdPicturePut(
          id,
          newPicture,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "JobsApi.updateJobPictureCurrentUserJobsMeIdPicturePut"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = JobsApiFp(configuration);
  return {
    /**
     *
     * @summary Create Job Current User
     * @param {JobCreate} jobCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobCurrentUserJobsMePost(
      jobCreate: JobCreate,
      options?: any,
    ): AxiosPromise<JobRead> {
      return localVarFp
        .createJobCurrentUserJobsMePost(jobCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Job Current User
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobCurrentUserJobsMeIdDelete(
      id: string,
      options?: any,
    ): AxiosPromise<Message> {
      return localVarFp
        .deleteJobCurrentUserJobsMeIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read Jobs Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readJobsCurrentUserJobsMeGet(options?: any): AxiosPromise<Array<JobRead>> {
      return localVarFp
        .readJobsCurrentUserJobsMeGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Job Current User
     * @param {string} id
     * @param {JobUpdate} jobUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJobCurrentUserJobsMeIdPatch(
      id: string,
      jobUpdate: JobUpdate,
      options?: any,
    ): AxiosPromise<JobRead> {
      return localVarFp
        .updateJobCurrentUserJobsMeIdPatch(id, jobUpdate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Job Picture Current User
     * @param {string} id
     * @param {File} newPicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJobPictureCurrentUserJobsMeIdPicturePut(
      id: string,
      newPicture: File,
      options?: any,
    ): AxiosPromise<JobRead> {
      return localVarFp
        .updateJobPictureCurrentUserJobsMeIdPicturePut(id, newPicture, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
  /**
   *
   * @summary Create Job Current User
   * @param {JobCreate} jobCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public createJobCurrentUserJobsMePost(
    jobCreate: JobCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return JobsApiFp(this.configuration)
      .createJobCurrentUserJobsMePost(jobCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Job Current User
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public deleteJobCurrentUserJobsMeIdDelete(
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return JobsApiFp(this.configuration)
      .deleteJobCurrentUserJobsMeIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read Jobs Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public readJobsCurrentUserJobsMeGet(options?: RawAxiosRequestConfig) {
    return JobsApiFp(this.configuration)
      .readJobsCurrentUserJobsMeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Job Current User
   * @param {string} id
   * @param {JobUpdate} jobUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public updateJobCurrentUserJobsMeIdPatch(
    id: string,
    jobUpdate: JobUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return JobsApiFp(this.configuration)
      .updateJobCurrentUserJobsMeIdPatch(id, jobUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Job Picture Current User
   * @param {string} id
   * @param {File} newPicture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public updateJobPictureCurrentUserJobsMeIdPicturePut(
    id: string,
    newPicture: File,
    options?: RawAxiosRequestConfig,
  ) {
    return JobsApiFp(this.configuration)
      .updateJobPictureCurrentUserJobsMeIdPicturePut(id, newPicture, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Read Profile Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readProfileCurrentUserProfilesMeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/profiles/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Profile Current User
     * @param {ProfileUpdate} profileUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileCurrentUserProfilesMePatch: async (
      profileUpdate: ProfileUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'profileUpdate' is not null or undefined
      assertParamExists(
        "updateProfileCurrentUserProfilesMePatch",
        "profileUpdate",
        profileUpdate,
      );
      const localVarPath = `/profiles/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        profileUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Read Profile Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readProfileCurrentUserProfilesMeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readProfileCurrentUserProfilesMeGet(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ProfilesApi.readProfileCurrentUserProfilesMeGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Profile Current User
     * @param {ProfileUpdate} profileUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfileCurrentUserProfilesMePatch(
      profileUpdate: ProfileUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProfileCurrentUserProfilesMePatch(
          profileUpdate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ProfilesApi.updateProfileCurrentUserProfilesMePatch"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfilesApiFp(configuration);
  return {
    /**
     *
     * @summary Read Profile Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readProfileCurrentUserProfilesMeGet(
      options?: any,
    ): AxiosPromise<ProfileRead> {
      return localVarFp
        .readProfileCurrentUserProfilesMeGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Profile Current User
     * @param {ProfileUpdate} profileUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileCurrentUserProfilesMePatch(
      profileUpdate: ProfileUpdate,
      options?: any,
    ): AxiosPromise<ProfileRead> {
      return localVarFp
        .updateProfileCurrentUserProfilesMePatch(profileUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
  /**
   *
   * @summary Read Profile Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public readProfileCurrentUserProfilesMeGet(options?: RawAxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .readProfileCurrentUserProfilesMeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Profile Current User
   * @param {ProfileUpdate} profileUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public updateProfileCurrentUserProfilesMePatch(
    profileUpdate: ProfileUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .updateProfileCurrentUserProfilesMePatch(profileUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Read Projects Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readProjectsCurrentUserProjectsMeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Project Current User
     * @param {string} id
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectCurrentUserProjectsMeIdPatch: async (
      id: string,
      projectUpdate: ProjectUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateProjectCurrentUserProjectsMeIdPatch", "id", id);
      // verify required parameter 'projectUpdate' is not null or undefined
      assertParamExists(
        "updateProjectCurrentUserProjectsMeIdPatch",
        "projectUpdate",
        projectUpdate,
      );
      const localVarPath = `/projects/@me/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Project Refresh Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectRefreshCurrentUserProjectsMeRefreshPut: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects/@me/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Read Projects Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readProjectsCurrentUserProjectsMeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ProjectRead>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readProjectsCurrentUserProjectsMeGet(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ProjectsApi.readProjectsCurrentUserProjectsMeGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Project Current User
     * @param {string} id
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProjectCurrentUserProjectsMeIdPatch(
      id: string,
      projectUpdate: ProjectUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProjectCurrentUserProjectsMeIdPatch(
          id,
          projectUpdate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ProjectsApi.updateProjectCurrentUserProjectsMeIdPatch"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Project Refresh Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProjectRefreshCurrentUserProjectsMeRefreshPut(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ProjectRead>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProjectRefreshCurrentUserProjectsMeRefreshPut(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ProjectsApi.updateProjectRefreshCurrentUserProjectsMeRefreshPut"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProjectsApiFp(configuration);
  return {
    /**
     *
     * @summary Read Projects Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readProjectsCurrentUserProjectsMeGet(
      options?: any,
    ): AxiosPromise<Array<ProjectRead>> {
      return localVarFp
        .readProjectsCurrentUserProjectsMeGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Project Current User
     * @param {string} id
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectCurrentUserProjectsMeIdPatch(
      id: string,
      projectUpdate: ProjectUpdate,
      options?: any,
    ): AxiosPromise<ProjectRead> {
      return localVarFp
        .updateProjectCurrentUserProjectsMeIdPatch(id, projectUpdate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Project Refresh Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectRefreshCurrentUserProjectsMeRefreshPut(
      options?: any,
    ): AxiosPromise<Array<ProjectRead>> {
      return localVarFp
        .updateProjectRefreshCurrentUserProjectsMeRefreshPut(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
  /**
   *
   * @summary Read Projects Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public readProjectsCurrentUserProjectsMeGet(options?: RawAxiosRequestConfig) {
    return ProjectsApiFp(this.configuration)
      .readProjectsCurrentUserProjectsMeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Project Current User
   * @param {string} id
   * @param {ProjectUpdate} projectUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public updateProjectCurrentUserProjectsMeIdPatch(
    id: string,
    projectUpdate: ProjectUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .updateProjectCurrentUserProjectsMeIdPatch(id, projectUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Project Refresh Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public updateProjectRefreshCurrentUserProjectsMeRefreshPut(
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .updateProjectRefreshCurrentUserProjectsMeRefreshPut(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ResumesApi - axios parameter creator
 * @export
 */
export const ResumesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResumeCurrentUserResumesMePost: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/resumes/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResumeCurrentUserResumesMeDelete: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/resumes/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResumeCurrentUserResumesMeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/resumes/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Resume Current User
     * @param {ResumeUpdate} resumeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResumeCurrentUserResumesMePatch: async (
      resumeUpdate: ResumeUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resumeUpdate' is not null or undefined
      assertParamExists(
        "updateResumeCurrentUserResumesMePatch",
        "resumeUpdate",
        resumeUpdate,
      );
      const localVarPath = `/resumes/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resumeUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResumesApi - functional programming interface
 * @export
 */
export const ResumesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResumesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResumeCurrentUserResumesMePost(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createResumeCurrentUserResumesMePost(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResumesApi.createResumeCurrentUserResumesMePost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResumeCurrentUserResumesMeDelete(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteResumeCurrentUserResumesMeDelete(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ResumesApi.deleteResumeCurrentUserResumesMeDelete"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readResumeCurrentUserResumesMeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readResumeCurrentUserResumesMeGet(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResumesApi.readResumeCurrentUserResumesMeGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Resume Current User
     * @param {ResumeUpdate} resumeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResumeCurrentUserResumesMePatch(
      resumeUpdate: ResumeUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResumeRead>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateResumeCurrentUserResumesMePatch(
          resumeUpdate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ResumesApi.updateResumeCurrentUserResumesMePatch"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ResumesApi - factory interface
 * @export
 */
export const ResumesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ResumesApiFp(configuration);
  return {
    /**
     *
     * @summary Create Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResumeCurrentUserResumesMePost(
      options?: any,
    ): AxiosPromise<ResumeRead> {
      return localVarFp
        .createResumeCurrentUserResumesMePost(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResumeCurrentUserResumesMeDelete(
      options?: any,
    ): AxiosPromise<Message> {
      return localVarFp
        .deleteResumeCurrentUserResumesMeDelete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read Resume Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResumeCurrentUserResumesMeGet(options?: any): AxiosPromise<ResumeRead> {
      return localVarFp
        .readResumeCurrentUserResumesMeGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Resume Current User
     * @param {ResumeUpdate} resumeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResumeCurrentUserResumesMePatch(
      resumeUpdate: ResumeUpdate,
      options?: any,
    ): AxiosPromise<ResumeRead> {
      return localVarFp
        .updateResumeCurrentUserResumesMePatch(resumeUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ResumesApi - object-oriented interface
 * @export
 * @class ResumesApi
 * @extends {BaseAPI}
 */
export class ResumesApi extends BaseAPI {
  /**
   *
   * @summary Create Resume Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResumesApi
   */
  public createResumeCurrentUserResumesMePost(options?: RawAxiosRequestConfig) {
    return ResumesApiFp(this.configuration)
      .createResumeCurrentUserResumesMePost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Resume Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResumesApi
   */
  public deleteResumeCurrentUserResumesMeDelete(
    options?: RawAxiosRequestConfig,
  ) {
    return ResumesApiFp(this.configuration)
      .deleteResumeCurrentUserResumesMeDelete(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read Resume Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResumesApi
   */
  public readResumeCurrentUserResumesMeGet(options?: RawAxiosRequestConfig) {
    return ResumesApiFp(this.configuration)
      .readResumeCurrentUserResumesMeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Resume Current User
   * @param {ResumeUpdate} resumeUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResumesApi
   */
  public updateResumeCurrentUserResumesMePatch(
    resumeUpdate: ResumeUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ResumesApiFp(this.configuration)
      .updateResumeCurrentUserResumesMePatch(resumeUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
